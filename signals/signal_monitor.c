/* signal_monitor.c */
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/resource.h>

#include <bpf/libbpf.h>
#include <bpf/bpf.h>

#include "signal_monitor.skel.h" // Generated by bpftool or libbpf



#define EVENT_RINGBUF_SIZE 4096

struct ring_buffer *rb = NULL;

struct signal_event {
    pid_t pid;
    int sig;
    int uid;
};

static void handle_event(void *ctx, int cpu, void *data, __u32 size) {
    //printf("ENTROUUUU\n");
    struct signal_event *event = data; 
    int ret_consume = 0; // ring_buffer__consume(rb);

    if (ret_consume < 0){
        printf("Erro ao consumir o ringbuf\n");
    }
    // rb->ALGUMA_COISA
    //printf("Signal %d sent to PID %d (TGID %d)\n", event->sig, event->pid, event->uid);
}

/**********************************************************/
int main() {
    struct signal_monitor_bpf *skel;
   // struct ring_buffer *rb = NULL;
    int err;

    // Increase memory limits for eBPF
    struct rlimit r = {RLIM_INFINITY, RLIM_INFINITY};
    setrlimit(RLIMIT_MEMLOCK, &r);

    // Load and verify eBPF program
    skel = signal_monitor_bpf__open_and_load();
    if (!skel) {
        fprintf(stderr, "Failed to open and load eBPF program\n");
        return 1;
    }

    // Attach the eBPF program
    err = signal_monitor_bpf__attach(skel);
    if (err) {
        fprintf(stderr, "Failed to attach eBPF program\n");
        goto cleanup;
    }

    printf("\n<Programa carregado>\n");
    
    // Set up ring buffer polling
    rb = ring_buffer__new(bpf_map__fd(skel->maps.events ), (void *)handle_event, NULL, NULL);
    
    //struct user_ring_buffer *urb;
    //urb = user_ring_buffer__new(bpf_map__fd(skel->maps.events ), NULL); //(void *)handle_event, NULL, NULL);
    if (!rb) {
        fprintf(stderr, "Failed to create ring buffer\n");
        goto cleanup;
    }

    printf("Monitoring signals... Press Ctrl+C to stop.\n");

    while (1) {
        //printf("Entrou laco\n\n");
        err = ring_buffer__poll(rb, 100);
        if (err < 0) {
            fprintf(stderr, "Error polling ring buffer\n");
            break;
        }
    }

cleanup:
    ring_buffer__free(rb);
    signal_monitor_bpf__destroy(skel);
    return 0;
}
